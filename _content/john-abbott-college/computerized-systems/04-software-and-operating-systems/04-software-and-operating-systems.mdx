---
# General Information
category: "Computerized Systems"
title: "Software and Operating Systems"
created: "2024-09-04"
coverSrc: "./assets/"
---

# Recap

Hardware refers to any part of the computer with a physical structure. But which components are the most important?

## CPU (Central Processing Unit)

The CPU is the "brain" of the computer, responsible for executing the instructions of a software program. The "power" of a CPU is determined by how many instructions it can execute per second, usually measured in `gigahertz (GHz)`, representing billions of instructions per second.

## RAM (Random Access Memory)

RAM acts as the computer's "short-term memory." It temporarily holds information while the CPU processes it, allowing for quick access to the data needed for running programs and tasks.

## Storage Drives

Storage drives serve as the computer's "long-term memory." This means that data is saved even when the computer is turned off or unplugged. When you run a program or open a file, the computer copies some of the data from the storage drive to the RAM. When you save a file, the data is copied back to the drive.

The storage capacity of a hard drive is measured in `gigabytes (GB)`, the same unit used to measure RAM.

# Software

Software is a set of instructions that tells the hardware what to do and how to do it. The programs running on a computer are collectively referred to as "software" and can be divided into two main categories:

- Operating Systems: These include systems like MacOS, Windows, iOS, Android, and Linux. They manage the hardware and provide a platform for other software to run.
- Application Software: These are programs like Microsoft Word, Excel, and Google Chrome, designed to perform specific tasks for the user.

# Operating Systems

## Origin Story

Early computers could only run 1 program at a time. A programmer would write one at their desk on a "punch card" then carry it to be executed by a room sized computer. This process was deeply manual requiring someone to operate and the overall program could take days to weeks to finish executing before giving an output. You could imagine that this was less than ideal as if a programmer introduced a single bug with their program, the consequences were costly.

With the advent of transistors, computers became exponentially faster and smaller and we needed a way for computers to operate themselves and therefore operating systems were born.

## What are operating systems?

Operating Systems (OS) are programs with special privileges that allow them to work directly with the hardware. This is what gives them the ability to manage other programs. It is typically the first program to start when the computer is turned on and all other programs then get turned on by the OS.

## Why is it so neat to have self managing computers?

They got their start in the 1950s, as computers became more widespread and more powerful. The very first OSs augmented the mundane and tedious task of loading programs by hand.

## What were the early problems?

The early problems with one-off computers arose from the fact that each machine was unique, requiring programmers to write code specifically tailored to the hardware of that particular device. As computers became more widespread, this lack of standardization became a significant issue, as programs written for one machine often didn't work on another. Even when the CPUs were the same, differences in input and output devices meant that programmers had to write low-level code, understanding the intricate details of each device.

What made the problem worse was that programmers rarely had access to all the different models of devices they were coding for and their manuals. In a lot of ways, writing code then was like throwing stuff at the wall and hoping it'd stick. Another way to think about this is imagine if every time you got a new pair of headphones, you had to read hundred of pages of manuals to configure your phone to connect to this device. You would probably try a million things and pray for it to work. Yeah it was like that.

## How did we fix these problems?

To address these issues, the computing industry moved towards standardization and the development of operating systems. Operating systems provided a common interface between the hardware and software, allowing programmers to write code that could run on different machines without needing to know the specifics of each device.

Did you need to know what printer you were connected to? What monitor you were working on? Whether you had an ergonomic mouse vs a standard one? Absolutely not.

This abstraction meant that instead of writing low-level code for every possible configuration, programmers could rely on the operating system to handle the details, making their programs more portable and easier to maintain.

## Early operating systems

The most influential of early operating systems was Multics released in 1969, however it sparked some controversy as
one of it's creators, Denis Ritchie, claimed that it was "it was over-engineered... There was too much in it." and so he went off to create "Unix".

## What do you think was the early solution to error handling in the OS?

If there's an error, they would have this routine called `PANIC`, and when it is called, the machine crashes and goes into an vegetable like state.

Why would we ever want this?

It was simpler and cheeper so the OS could run on diverse hardware. By leaving out any effective error handling, the OS was portable and consequently it went on to become all the rage in the 70s and 80s.

Eventually there came other OS that dominated the market share in the 90s, you might have heard of them, "Microsoft" that even had it's own janky way of handling errors.

How many of you ever encountered a blue screen of death? This is the result of a program that crashed so badly that it took down the entire operating system.

## What are some examples of Modern Operating Systems?

- MacOS
- Windows
- iOS
- Android
- Linux

## Why are modern operating systems cool?

They are a set of programs that:

- Run inside the hardware
- Communicates with and manages the hardware
- Hosts and runs application software, allowing application software to work with CPU Performs general housekeeping tasks for your computer: like system maintenance and file compression
- User Interface: how users interact with the computer (command line, menu, or Graphical User Interface -GUI)
- Can multitask

# Achnologements

The lecture content was adapted from Meghrig Terzian and Pretti Peal's course notes, and took inspiration from [Crash Course](https://www.youtube.com/watch?v=O5nskjZ_GoI&t=148s)
