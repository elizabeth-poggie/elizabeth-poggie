---
# General Information
category: "Web Programming I"
title: "Arrays and Equality"
created: "2024-09-06"
coverSrc: "./assets/"
---

# Arrays continued

Going back to what we know about arrays, these are the functions we know so far:

```js
// Add a single item to the end of an array
myArray.push(item);
// Add multiple items to the end of an array
myArray.push(item1, item2);
// Remove the last item from an array
myArray.pop();
// Get the length of an array
myArray.length;
// Find the index of a specific item in the array
myArray.indexOf(findItem);
```

These allow us to dynamically resize and search the array much like a list data structure that you are familiar with from previous classes. But there are a few more that are worth knowing...

## Splicing

```js
// You can get the length of an array
myArray.splice(removeFromIndex, removeNumberOfElements, replacement1, replacement2, ...);
```

With `splice`, you can remove one or more elements from an array at a specific index as opposed to `pop()` which only lets you modify at the very end. For example:

```js
const fruits = ["apple", "banana", "cherry", "date"];
fruits.splice(1, 1);
console.log(fruits); // ["apple", "cherry", "date"]
```

`splice` can also be used to insert new elements into an array at a specific index, effectively "`splice`ing" them into place. For example:

```js
const fruits = ["apple", "cherry", "date"];
fruits.splice(1, 0, "banana");
console.log(fruits); // ["apple", "banana", "cherry", "date"]
```

This is also particularly useful when you need to replace specific elements by removing some and inserting new ones in their place. For example:

```js
const fruits = ["apple", "banana", "cherry", "date"];
fruits.splice(1, 1, "blueberry");
console.log(fruits); // ["apple", "blueberry", "cherry", "date"]
```

Whether you need to remove, insert, or replace elements, `splice` gives you the power to manipulate arrays in a way that other methods donâ€™t. Why would we ever need this? Well one example is in e-commerce sites. `splice` can be used to manage a user's shopping cart. For example, when a user removes an item from their cart, you can use `splice` to update the array of items.

```js
const cart = [
  { id: 1, name: "Laptop", price: 650 },
  { id: 2, name: "Phone", price: 500 },
  { id: 3, name: "Headphones", price: 100 },
];

// Remove the phone
cart.splice(1, 1);
// Print cart
console.log(cart);
```

Another could be managing a playlist where users might want to add, remove, or reorder songs. I invite you to think of potential use cases for this method :^)

## Iterating

The `forEach()` method iterates over the array without the need of an explicitly defined index. For example, going back to our boating school example, this is how we iterated over all the testing scores:

```js
// Traditional loop
for (let i = 0; i < student.tests.length; i++) {
  let test = student.tests[i];
  total += test.grade;
}
```

Alternatively, this can also be written like this:

```js
// Slightly fancier loops
for (let test of student.tests) {
  total += test.grade;
}
```

And using what we know about this `forEach()` method, we can do the following 1 liner:

```js
// Even fancier loops
student.tests.forEach(function (x) {
  total += test.grade;
});
```

And if anyone is curious about arrow notation, you can get this very sleek gentleman right here:

```js
// SLEEK loops ðŸ‘Œ
student.tests.forEach((test) => {
  total += test.grade;
});
```

In summary:

- `forEach()` does not modify the original array
- `forEach()` returns nothing and therefore the return value is `undefined`

However, there is an even sleeker way you can iterate over the contents of a loop, however thats for much later ðŸ‘€

# Exercise 1

# JavaScript Equality

For everyone who watched the full conference video on [WTFJS](https://www.youtube.com/watch?v=et8xNAc2ic8), today we are going finally to explore why he referred to the `==` as the "dick".

For starters, in JavaScript, shockingly `===` and `==` do not mean the same thing:

- When using triple `===` in JavaScript, we are testing form "strict" equality. This means both the `type` and `value` are being compared at the same time.

- When using double equals in JavaScript we are testing for "loose" equality. Double equals also performs a _type coercion_

# Type Coercion Side Tangent

Type coercion in programming refers to the automatic or implicit conversion of values from one data type to another. In languages like JavaScript, this often happens when values of different types are compared or when operations are performed that expect a certain type of value.

Going back to one of our earlier examples:

```js
let result = "5" - 2; // 3
```

JavaScript converts the string `5` to a number, and then subtracts `2` from `5`, resulting in `3`. Alternatively:

```js
let result = "5" + 2; // 52
```

JavaScript converts the number `2` to a string, and then concatenates that with `5`, resulting in `52`.

```js
let result = true + true; // 2
```

Here JavaScript is converting `true` into 1, and so `1+1` is `2` :^)

In the case with `==` equality, _type coercion_ means that two values are compared only AFTER attempting to convert them into a common type. What does that mean for you?

# Comparisons that are Unfortunately Valid

## Comparing a Number and a String

```js
console.log(5 == "5"); // true
```

This makes sense because the string `5` is coerced into the number `5`, and the comparison evaluates to `true`.

## Comparing a Boolean and a Number

```js
console.log(0 == false); // true
```

This also makes sense because in this case, `false` is coerced into the number `0`, so the comparison is `true`.

## Comparing a Boolean and a string

```js
console.log("" == false); // true
```

An empty string `""` is coerced into `false`, so the comparison evaluates to `true`.

## Comparing null and undefined

```js
console.log(null == undefined); // true
```

In JavaScript, `null` and `undefined` are considered equal with `==`, but they are not equal with `===` because it's JavaScript.

```js
console.log(null === undefined); // false :^)
```

## Compounding Coercions

Both sides of the `==` can be coerced. For example:

```js
console.log("0" == false); // true
```

This is unfortunately valid because:

- the string `"0"` is coerced into a number
- the boolean `false` is coerced into a number
- both these numbers are then compared `0 == 0`
- And thus it prints `true` :^)

# Comparisons that are Strangely not Valid

Ok so that's weird, but what's weirder are the things that are not allowed.

## Comparing null with a Boolean

```js
console.log(null == false); // false
```

What is happening here????? `null` and `undefined` are considered equal to each other ONLY for `==` but not to other values. That means `null == undefined` is `true`, but `null == false` is `false`.

## Comparing Arrays with Object

```js
console.log([] == {}); // false
```

ok so arrays and objects are not the same. BUT:

```js
console.log(typeof [] == typeof {}); // true
```

Their types are the same??? Despite this, they are different kinds of objects. Arrays are specialized objects with additional array methods and properties, while plain objects are general-purpose collections of key-value pairs.

## What's the take away

Do not use the `==` operator.
