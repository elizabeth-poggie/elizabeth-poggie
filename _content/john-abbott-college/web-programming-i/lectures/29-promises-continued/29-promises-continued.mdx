---
# General Information
category: "Web Programming I"
title: "Promises Continued"
created: "2024-10-31"
number: 29
---

# Promises

Let's continue what we talked about on tuesday with a more concrete example.

## What is a promise?

It is something that is unknown now and may become known sometime in the future.

## From Concept to JavaScript

Poggie "promises" to grade your Assignment 2. Here’s how this would look in JavaScript:

```js
function poggieMustGrade(assignment) {
  return new Promise(function (resolve, reject) {
    // poggie "promises" to grade your stuff
  });
}
```

Poggie has set her grading deadline for Wednesday, and she made this promise to the class on Tuesday. In JavaScript, this setup would look like this:

```js
function poggieMustGrade(assignment) {
  return new Promise(function (resolve, reject) {
    // Set a deadline (Wednesday)
    const deadline = new Date("2024-10-30");

    // simulate a wait period of 3 seconds instead of 3 days
    setTimeout(() => {
      // Get today's date
      const today = new Date();
      if (today <= deadline) {
        resolve(`Poggie graded your ${assignment.name} on time (wow)`);
      } else {
        reject(
          `Poggie slept thru her deadline and failed to grade your ${assignment.name}`
        );
      }
    }, 3000);
  });
}
```

Initially, the promise is _pending_. After "3 days," the promise either gets `resolve`d (you receive feedback) or `reject`ed (you don’t get feedback)

Here’s how you’d call this promise:

```js
poggieMustGrade({
  name: "Assignment 2",
  content: "some really cool code",
});
```

Using `then` to handle the result of the promise once fulfilled would look like this:

```js
poggieMustGrade({
  name: "Assignment 2",
  content: "some really cool code",
})
  .then((message) => {
    console.log(message);
  })
  .catch((error) => {
    console.log(error);
  });
```

Since today is Friday, you should expect this output:

```text
Poggie slept thru her deadline and failed to grade your Assignment 2
```

But if Poggie had `resolve`d grading your assignment on time, you’d see:

```text
Poggie graded your Assignment 2 on time (wow)
```

## What if I want to “chain” multiple actions together?

For example, after Poggie has graded your assignment, you want to check Lea for your grade.

## Chaining

Let’s add a new function called `checkGrade` that takes a `feedback` object and returns a boolean indicating whether you’ve read it:

```js
// example feedback object
const feedback = {
  grade: 0.8,
  comments: ["blah", "blah", "blah"],
};

// example method
function checkGrade(feedback) {
  console.log(`grade: ${feedback.grade}`);
  feedback.comments.forEach((comment) => {
    console.log(`${comment}`);
  });
  return true;
}
```

Now, we’ll set the deadline for _Sunday_ and modify the resolve statement to return a `feedback` object:

```js
resolve({ grade: 0.8, comments: ["blah", "blah"] });
```

You only want to check Lea once you’re sure there’s feedback; otherwise what's the point? Do you want to check Lea before the operation is complete? Absolutely not.

So, let’s handle the promise response only once there’s some sort of notification:

```js
poggieMustGrade({
  name: "Assignment 2",
  content: "some really cool code",
})
  .then((feedback) => {
    checkGrade(feedback);
  })
  .catch((error) => {
    console.log(error);
  });
```

## Why is this so neat?

We only trigger the `checkGrade` method AFTER the assignment is graded. What's cooler? We can keep chaining methods as needed :)

Let’s say you get a notification once you’ve checked your grade. Here’s what that would look like:

```js
// another method
function sendPoggieDM(res) {
  if (res) {
    console.log("wow the student left me on read");
  }
}
```

Now, we can consume these responses quite elegantly like so:

```js
// updated chaining
poggieMustGrade({
  name: "Assignment 2",
  content: "some really cool code",
})
  .then((feedback) => {
    return checkGrade(feedback); // notice the return
  })
  .then((response) => {
    sendPoggieDM(response);
  })
  .catch((error) => {
    console.log(error);
  });
```

## Helpful tip

When you start creating promises, it’s easy to mess it up. This is where effective error handling in your catch block is important 👀

# Exercise 1

You are a student that needs to submit an essay. Once this essay is created, it should be reviewed, and then finally submitted on Lea once finished. How could you do this in JavaScript?

## Requirements

Each task is asynchronous and takes `3000` milliseconds to complete.

## Solution

```js
// Step 1: Create an Essay
function writeEssay(essay) {
  return new Promise((resolve, reject) => {
    console.log("Creating essay...");
    setTimeout(() => {
      if (essay.content) {
        resolve({ ...essay, id: 1, status: "created" });
      } else {
        reject("Failed to write essay lol");
      }
    }, 3000);
  });
}

// Step 2: Review the Essay
function reviewEssay(essay) {
  return new Promise((resolve, reject) => {
    console.log("Reviewing essay...");
    setTimeout(() => {
      if (essay.status === "created") {
        resolve({ ...essay, status: "reviewed" });
      } else {
        reject("Didn't Review lol");
      }
    }, 3000);
  });
}

// Step 3: Submit the essay
function submitEssay(essay) {
  return new Promise((resolve, reject) => {
    console.log("Submitting Essay on Lea...");
    setTimeout(() => {
      if (essay.status === "reviewed") {
        resolve({ ...essay, status: "submitted" });
      } else {
        reject("Cannot submit essay: Omnivox is down again lol");
      }
    }, 3000);
  });
}

// Chaining the functions
writeEssay({ title: "Humanities Essay", content: "Wow this is an essay" })
  .then((essay) => reviewEssay(essay))
  .then((essay) => submitEssay(essay))
  .then((essay) => console.log("Essay status:", essay.status)) // Should print "submitted"
  .catch((error) => console.error(error));
```

# Async / Await

Alright so know that `Promises` are a huge improvement from "callback hell", but promises can start getting hard to read when you have a lot of stuff chained together.

## Where does Async Await come in?

All it boils down to is a cuter way to handle your asynchronous code.

## Rewriting our example

The synchronous functions will stay the same, however now the `poggieMustGrade` function will look like this:

```js
// declare the function with "async"
async function poggieMustGrade(assignment) {
  const deadline = new Date("2024-11-03");

  // TODO - Simulate a wait period of 3 seconds instead of 3 days

  const today = new Date();
  if (today <= deadline) {
    return { grade: 0.8, comments: ["blah", "blah"] };
  } else {
    throw new Error(
      `Poggie slept thru her deadline and failed to grade your ${assignment.name}`
    );
  }
}
```

Our async code now looks a lot like sync code!! Handling it would look like this:

```js
try {
  // "await" the response
  const feedback = await poggieMustGrade({
    name: "Assignment 2",
    content: "some really cool code",
  });
  // synchronous code
  const response = checkGrade(feedback);
  sendPoggieDM(response);
} catch (error) {
  console.log(error.message);
}
```

Error handling is so much cleaner now since all we need to do is wrap it in a `try catch`

## Why is this neat?

With traditional promises, it's difficult to share resolved values between multiple steps in the promise chain

## Common failures

You only need to await one thing after another if the second value is dependent on the first value.

For example take the below code:

```js

```

Now we can run it "concurrently" like so:

```js
return Promise.all();
```

Our code is better now since it's non-blocking and we are using our event loop effectively :^) So instead of awaiting for a bunch of individual promises, its better to resolve them all at once.

# Fancy server calls

Here is a bad way with map where we call the server one at a time

```js
const urls = ["1", "2", "3"];
urls.map((v) => getData(v));

function async getData(url) {

}
```

Here is better

```js
for await
```

```js
if await
```

super concise way to work with promises
