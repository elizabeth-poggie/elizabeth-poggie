---
# General Information
category: "Web Programming I"
title: "Promises Continued"
created: "2024-10-31"
number: 29
---

# Promises

Let's continue what we talked about on tuesday with a more concrete example.

## What is a promise?

It is something that is unknown now and may become known sometime in the future.

## From Concept to JavaScript

Poggie "promises" to grade your Assignment 2. Here’s how this would look in JavaScript:

```js
function poggieMustGrade(assignment) {
  return new Promise(function (resolve, reject) {
    // poggie "promises" to grade your stuff
  });
}
```

Poggie has set her grading deadline for Wednesday, and she made this promise to the class on Tuesday. In JavaScript, this setup would look like this:

```js
function poggieMustGrade(assignment) {
  return new Promise(function (resolve, reject) {
    // Set a deadline (Wednesday)
    const deadline = new Date("2024-10-30");

    // simulate a wait period of 3 seconds instead of 3 days
    setTimeout(() => {
      // Get today's date
      const today = new Date();
      if (today <= deadline) {
        resolve(`Poggie graded your ${assignment.name} on time (wow)`);
      } else {
        reject(
          `Poggie slept thru her deadline and failed to grade your ${assignment.name}`
        );
      }
    }, 3000);
  });
}
```

Initially, the promise is _pending_. After "3 days," the promise either gets `resolve`d (you receive feedback) or `reject`ed (you don’t get feedback)

Here’s how you’d call this promise:

```js
poggieMustGrade({
  name: "Assignment 2",
  content: "some really cool code",
});
```

Using `then` to handle the result of the promise once fulfilled would look like this:

```js
poggieMustGrade({
  name: "Assignment 2",
  content: "some really cool code",
})
  .then((message) => {
    console.log(message);
  })
  .catch((error) => {
    console.log(error);
  });
```

Since today is Friday, you should expect this output:

```text
Poggie slept thru her deadline and failed to grade your Assignment 2
```

But if Poggie had `resolve`d grading your assignment on time, you’d see:

```text
Poggie graded your Assignment 2 on time (wow)
```

## What if I want to “chain” multiple actions together?

For example, after Poggie has graded your assignment, you want to check Lea for your grade.

## Chaining

Let’s add a new function called `checkGrade` that takes a `feedback` object and returns a boolean indicating whether you’ve read it:

```js
// example feedback object
const feedback = {
  grade: 0.8,
  comments: ["blah", "blah", "blah"],
};

// example method
function checkGrade(feedback) {
  console.log(`grade: ${feedback.grade}`);
  feedback.comments.forEach((comment) => {
    console.log(`${comment}`);
  });
  return true;
}
```

Now, we’ll set the deadline for _Sunday_ and modify the resolve statement to return a `feedback` object:

```js
resolve({ grade: 0.8, comments: ["blah", "blah"] });
```

You only want to check Lea once you’re sure there’s feedback; otherwise what's the point? Do you want to check Lea before the operation is complete? Absolutely not.

So, let’s handle the promise response only once there’s some sort of notification:

```js
poggieMustGrade({
  name: "Assignment 2",
  content: "some really cool code",
})
  .then((feedback) => {
    checkGrade(feedback);
  })
  .catch((error) => {
    console.log(error);
  });
```

## Why is this so neat?

We only trigger the `checkGrade` method AFTER the assignment is graded. What's cooler? We can keep chaining methods as needed :)

Let’s say you get a notification once you’ve checked your grade. Here’s what that would look like:

```js
// another method
function sendPoggieDM(res) {
  if (res) {
    console.log("wow the student left me on read");
  }
}
```

Now, we can consume these responses quite elegantly like so:

```js
// updated chaining
poggieMustGrade({
  name: "Assignment 2",
  content: "some really cool code",
})
  .then((feedback) => {
    return checkGrade(feedback); // notice the return
  })
  .then((response) => {
    sendPoggieDM(response);
  })
  .catch((error) => {
    console.log(error);
  });
```

## Helpful tip

When you start creating promises, it’s easy to mess it up. This is where effective error handling in your catch block is important 👀

# Exercise 1

You are a student that needs to submit an essay. Once this essay is created, it should be reviewed, and then finally submitted on Lea once finished. How could you do this in JavaScript?

## Requirements

Each task is asynchronous and takes `3000` milliseconds to complete.

## Solution

```js
// Step 1: Create an Essay
function writeEssay(essay) {
  return new Promise((resolve, reject) => {
    console.log("Creating essay...");
    setTimeout(() => {
      if (essay.content) {
        resolve({ ...essay, id: 1, status: "created" });
      } else {
        reject("Failed to write essay lol");
      }
    }, 3000);
  });
}

// Step 2: Review the Essay
function reviewEssay(essay) {
  return new Promise((resolve, reject) => {
    console.log("Reviewing essay...");
    setTimeout(() => {
      if (essay.status === "created") {
        resolve({ ...essay, status: "reviewed" });
      } else {
        reject("Didn't Review lol");
      }
    }, 3000);
  });
}

// Step 3: Submit the essay
function submitEssay(essay) {
  return new Promise((resolve, reject) => {
    console.log("Submitting Essay on Lea...");
    setTimeout(() => {
      if (essay.status === "reviewed") {
        resolve({ ...essay, status: "submitted" });
      } else {
        reject("Cannot submit essay: Omnivox is down again lol");
      }
    }, 3000);
  });
}

// Chaining the functions
writeEssay({ title: "Humanities Essay", content: "Wow this is an essay" })
  .then((essay) => reviewEssay(essay))
  .then((essay) => submitEssay(essay))
  .then((essay) => console.log("Essay status:", essay.status)) // Should print "submitted"
  .catch((error) => console.error(error));
```

# Async / Await

Alright so know that `Promises` are a huge improvement from "callback hell", but promises can start getting hard to read when you have a lot of stuff chained together.

## Where does Async Await come in?

All it boils down to is a cuter way to handle your asynchronous code.

- `async` 👉 A keyword used to declare a function that will handle asynchronous actions
- `await` 👉 A keyword used to pause the function until a promise is `resolve`d or `reject`ed

Let’s rewrite our example with `async` and `await` to see how it changes.

## Rewriting our example

The synchronous functions will stay the same, however now the `poggieMustGrade` function will look like this:

```js
// declare the function with "async"
async function poggieMustGrade(assignment) {
  const deadline = new Date("2024-11-03");

  // TODO - Simulate a wait period of 3 seconds instead of 3 days

  const today = new Date();
  if (today <= deadline) {
    return { grade: 0.8, comments: ["blah", "blah"] };
  } else {
    throw new Error(
      `Poggie slept thru her deadline and failed to grade your ${assignment.name}`
    );
  }
}
```

The `poggieMustGrade` function is declared as async, which means that we will eventually need to `await` it's resolution comme ca:

```js
try {
  // "await" the response
  const feedback = await poggieMustGrade({
    name: "Assignment 2",
    content: "some really cool code",
  });
  // synchronous code can now be executed
  const response = checkGrade(feedback);
  sendPoggieDM(response);
} catch (error) {
  console.log(error.message);
}
```

Error handling is so much cleaner now since all we need to do is wrap it in a `try catch`

## Can we have awaits inside of async functions?

Yeee, we can put the following in our `poggieMustGrade` function:

```js
// Simulate a wait period of 3 seconds instead of 3 days
await new Promise((resolve) => setTimeout(resolve, 3000));
```

💡 Note: Once you have an `await` in a function, it means you need to make the _overall_ function `async`

# Promise.all()

With traditional promises, it's difficult to share resolved values between multiple steps in the promise chain. `async` and `await` fixes this

## Common failures

You only need to await one thing after another _if the second value is dependent on the first value_.

For example, let's say I have the following method:

```js
// simple function
const getIngredient = async (name) => {
  // walk to kitchen delay
  await new Promise((resolve) => setTimeout(resolve, 1500));
  // return ingredient
  return Promise.resolve(name);
};
```

To make a sandwich I could do the following

```js
const badSandwich = async () => {
  const ing1 = await getIngredient("bread");
  const ing2 = await getIngredient("peanut butter");
  const ing3 = await getIngredient("jelly");
  return [ing1, ing2, ing3, ing1]; // 🥪
};
```

And call it like this:

```js
try {
  const food = await badSandwich();
  console.log(food);
} catch (error) {
  console.log(error.message);
}
```

However this is a `badSandwich`, what happens if we want to make a `betterSandwich`? We can run instead call `getIngredient` "concurrently" like so:

```js
const betterSandwich = async () => {
  const [ing1, ing2, ing3] = await Promise.all([
    getIngredient("bread"),
    getIngredient("peanut butter"),
    getIngredient("jelly"),
  ]);
  return [ing1, ing2, ing3, ing1]; // 🥪
};
```

Using `Promise.all` is better since we are creating non-blocking code!! We are using our event loop effectively :^)

# Exercise 2

# Fancy server calls

Here is a bad way with map where we call the server one at a time

```js
const urls = ["1", "2", "3"];
urls.map((v) => getData(v));

function async getData(url) {

}
```

Here is better

```js
for await
```

```js
if await
```

super concise way to work with promises

## (not so) Fun Fact

async/await is the industry standard :^)

# Exercise 2
