---
# General Information
category: "Web Programming I"
title: "async await execution flow"
created: "2024-11-11"
number: 32
---

# Quick Recap

## .then() vs Callbacks

```js
// callback hell
call1(function (result1, error1) {
  if (error1) {
    //handle error
  }
  call2(result1, function (result2, error2) {
    if (error2) {
      //handle error
    }
    call3(result2, function (result3, error2) {
      if (error3) {
        //handle error
      }
      // do something with result3
    });
  });
});
```

In the above code, each function (`call1`, `call2`, and `call3`) depends on the result of the _previous function_, leading to deeply nested callbacks. In callback hell, Error handling becomes repetitive and scattered.

We can fix this with `Promise`s comme ca:

```js
call1()
  .then((result1) => call2(result1))
  .then((result2) => call3(result2))
  .then((result3) => {
    // Do something with result3
  })
  .catch((error) => {
    // Handle errors in one place ❤️
  });
```

Promises are preferred to callback hell because:

- Clarity in execution
- Simplicity in error handling

## Modern Promises

To further simplify, you could use `async`/`await`:

```js
async function main() {
  try {
    const result1 = await call1();
    const result2 = await call2(result);
    const result3 = await call3(result2);
    // Do something with result3
  } catch (error) {
    // Handle errors
  }
}
```

Why do we love modern promises?

- The code reads like synchronous code
- You can share `result`s across multiple steps

## Promise.all

In the above examples, you need to `await` for one step to resolve before resolving the next step. However let's say their `result`s are _independent_ from each other. Then we can use `Promise.all()` to resolve things all at once:

```js
async function main() {
  try {
    const [result1, result2, result3] = await Promise.all([
      call1(),
      call2(),
      call3(),
    ]);
    // Do something with results
  } catch (error) {
    // Handle errors
  }
}
```

This allows their execution to run _concurrently_.

## Common Mistakes

- Putting an `await` statement at the "top level" instead of wrapping it in a `main` function
- `Promise.all` requires an array of promises
- Not `await`ing for ALL your promises to resolve (untracked promises are stinky)

# Flow of Execution

Using `async`/ `await` creates asynchronous code that looks "synchronous"

## Concrete Example

When does what print?

```js
let myPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("hi");
    console.log("C");
  }, 5000);
});
async function test() {
  // return new Promise( (resolve, reject) => {
  let result = await myPromise;
  console.log(result);
  //}
}

console.log("A");
let testReturn = test();
console.log("B");
```

You should see the following printed to the terminal:

```text
A
B
C
hi
```

## Why?

- Step 1) Console logs are "synchronous" so `console.log("A")` runs first
- Step ??) `let testReturn = test()` is `async` because it has an `await` so that returns a "pending promise"
- Step 2) `console.log("B")` the previous step returned a pending Promise that didn’t block the "main" thread, so we print `"B"` right after `"A"`
- Step ??) `myPromise`'s `setTimeout` begins counting down 5 seconds
- Step 3) `"C"` prints after 5 seconds.
- Step 4) Finally, `"hi"` prints after `C`, when `await myPromise` resolves.

# Mini Quiz

What is `Jimmy` assigned to?

## Q1

```js
let jimmy = new Promise((resolve, reject) => {
  resolve(2);
});
```

Jimmy will result in a:

```text
promise
```

## Q2

```js
fetch("http://cheese.com/brie").then((response) => {
  let jimmy = response.json();
});
```

Jimmy will result in a:

```text
promise
```

## Q3

```js
async function test() {
  return "cheese";
}
let bob = test();
```

Jimmy will ALSO result in a:

```text
promise
```

## Q4

```js
function foo() {
  return new Promise((resolve, reject) => resolve(2));
}
let jimmy = foo;
```

Jimmy will result in a:

```text
function
```

## Q5

```js
let jimmy = fetch("http://cheese.com/brie");
```

Jimmy will result in a:

```text
promise
```
