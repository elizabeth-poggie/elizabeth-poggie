---
# General Information
category: "Web Programming I"
title: "async await execution flow"
created: "2024-11-11"
number: 32
---

# Quick Recap

## .then() vs Callbacks

```js
// callback hell
call1(function (result1, error1) {
  if (error1) {
    //handle error
  }
  call2(result1, function (result2, error2) {
    if (error2) {
      //handle error
    }
    call3(result2, function (result3, error2) {
      if (error3) {
        //handle error
      }
      // do something with result3
    });
  });
});
```

In the above code, each function (`call1`, `call2`, and `call3`) depends on the result of the _previous function_, leading to deeply nested callbacks. In callback hell, Error handling becomes repetitive and scattered.

We can fix this with `Promise`s comme ca:

```js
call1()
  .then((result1) => call2(result1))
  .then((result2) => call3(result2))
  .then((result3) => {
    // Do something with result3
  })
  .catch((error) => {
    // Handle errors in one place ❤️
  });
```

Promises are preferred to callback hell because:

- Clarity in execution
- Simplicity in error handling

## Modern Promises

To further simplify, you could use `async`/`await`:

```js
async function main() {
  try {
    const result1 = await call1();
    const result2 = await call2(result);
    const result3 = await call3(result2);
    // Do something with result3
  } catch (error) {
    // Handle errors
  }
}
```

Why do we love modern promises?

- The code reads like synchronous code
- You can share `result`s across multiple steps

## Promise.all

In the above examples, you need to `await` for one step to resolve before resolving the next step. However let's say their `result`s are _independent_ from each other. Then we can use `Promise.all()` to resolve things all at once:

```js
async function main() {
  try {
    const [result1, result2, result3] = await Promise.all([
      call1(),
      call2(),
      call3(),
    ]);
    // Do something with results
  } catch (error) {
    // Handle errors
  }
}
```

This allows their execution to run _concurrently_.

## Common Mistakes

- Putting an `await` statement at the "top level" instead of wrapping it in a `main` function
- `Promise.all` requires an array of promises
- Not `await`ing for ALL your promises to resolve (untracked promises are stinky)
