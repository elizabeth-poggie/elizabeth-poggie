---
# General Information
category: "Web Programming I"
title: "Even More Promises"
created: "2024-11-04"
number: 30
---

# Promise.all()

With traditional promises, sharing resolved values across multiple steps in the chain could be tricky. `async` and `await` simplifies that. HOWEVER, we still want to run multiple asynchronous tasks at the same time, _especially if they're not dependent on each other_. This is why we love `Promise.all`

## Common failures

Only await tasks sequentially if they depend on each otherâ€™s results. If theyâ€™re _independent_, you can use `Promise.all` to run them "concurrently" (e.g. at the same time)

For example, let's say I have the following `async` function:

```js
// simple function
const getIngredient = async (name) => {
  // walk to kitchen delay
  await new Promise((resolve) => setTimeout(resolve, 1500));
  // return ingredient
  return Promise.resolve(name);
};
```

Now, hereâ€™s a function that uses this to make a sandwich:

```js
const badSandwich = async () => {
  const ing1 = await getIngredient("bread");
  const ing2 = await getIngredient("peanut butter");
  const ing3 = await getIngredient("jelly");
  return [ing1, ing2, ing3, ing1]; // ðŸ¥ª
};
```

To make a sandwich:

```js
try {
  const food = await badSandwich();
  console.log(food);
} catch (error) {
  console.log(error.message);
}
```

However, this is a `badSandwich` because each ingredient waits for the previous one. Letâ€™s make a `betterSandwich` using `Promise.all`:

```js
const betterSandwich = async () => {
  const [ing1, ing2, ing3] = await Promise.all([
    getIngredient("bread"),
    getIngredient("peanut butter"),
    getIngredient("jelly"),
  ]);
  return [ing1, ing2, ing3, ing1]; // ðŸ¥ª
};
```

Using `Promise.all` allows us to get each ingredient "concurrently", which makes the code faster and more efficient. In `betterSandwich` weâ€™re taking full advantage of _non-blocking code_ and using the event loop effectively :^)

# Exercise 1

# Real World Application

Let's take what we know about `fetch`ing data from an API and do this elegantly with `async` and await

Fo example, let's get a bunch of pokemons the bad way with the following syntax:

```js
const urls = [
  "https://pokeapi.co/api/v2/pokemon/ditto",
  "https://pokeapi.co/api/v2/pokemon/pikachu",
  "https://pokeapi.co/api/v2/pokemon/squirtle",
];

const getData = async (url) => {
  const data = await fetch(url);
  return data.json();
};

// Step 1 - get a bunch of pokemon promises using map
const pokemonPromises = urls.map(async (v) => getData(v));

// Step 2 - resolve them all at once
console.log(await Promise.all(pokemonPromises));
```

That looks great but you need to be careful when you use `async` and `await` when working with `map` and `forEach`. It wont actually pause the function in this context:

```js
const pokemonPromises = urls.map(async (url) => {
  // not being paused like you may think
  const data = await fetch(url);
  return data.json();
});

// everything concurrently
console.log(await Promise.all(pokemonPromises));
```

Alternatively, if you want stuff to happen one at a time instead of concurrently, you can use the following (sleek) syntax:

```js
const pokemons = [];

const pokemonLoop = async () => {
  for await (const url of urls) {
    const pokemon = await fetch(url);
    pokemons.push(pokemon);
  }
};

await pokemonLoop();

console.log(pokemons);
```

## (not so) Fun Fact

async/await is the industry standard :^)

# Exercise 2

Using what you know about `fetch`, try to call the Pokemon API using the `async` / `await` way of doing things
