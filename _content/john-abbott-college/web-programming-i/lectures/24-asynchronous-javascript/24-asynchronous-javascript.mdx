---
# General Information
category: "Web Programming I"
title: "Asynchronous JavaScript"
created: "2024-10-20"
number: 24
---

# Quick Recap

Last week, we took time to familiarize ourselves with the syntax associated with the Intersection Observer API. Today we are going to get more into the theory

# Asynchronous Programming

Async programming allows code to execute without blocking the main thread, enabling other operations to continue while waiting for other tasks to complete.

## How does this relate to Web Development?

This is especially important in web development to avoid freezing or slowing down a page while waiting for resources from a server.

## In the context of Web Development, what is the main thread?

In the context of web development, the main thread refers to the single thread where most of the execution of JavaScript, rendering of HTML/CSS, event handling, and general browser operations occur.

## What blocks the main thread?

JavaScript is traditionally single-threaded, meaning it runs one task at a time on the main thread. However many things we do in the web tend to be time consuming or "blocking" causing the browser to freeze or become unresponsive.

## What are common blocking operations?

Synchronous tasks (like loops or long computations) can block the main thread, preventing it from doing other work. Some examples include:

- Long loops and complex calculations
- Modifying the DOM and heavy DOM traversal (e.g. animations)
- Any synchronous file operations (e.g. reading large files using local file access)
- Parsing Large JSON

## How does Async Programming help?

To prevent blocking the main thread, web developers use asynchronous programming to offload tasks that can take time, such as `fetch`ing data from a server or performing complex calculations.

## Why is this so useful?

The browser can continue to render and respond to user interactions while the task completes in the background.

# Async Programming and the IntersectionObserver API

## Why does async programming relate to the IntersectionObserver API?

The Intersection Observer API allows you to "asynchronously" observe changes in the intersection of a `target` element within a viewport. The main benefits include and are not limited to:

- Non blocking behavior
- Efficient Resource Loading

## Non-blocking Behavior

The Intersection Observer API performs asynchronous observation of elements. You specify what to `observe()`

```js
observer.observe(someElement);
```

When the conditions are met (like an element entering the viewport), a "callback" is triggered.

```js
const observer = new IntersectionObserver(callback);
```

This happens asynchronously, without blocking the main thread which improves performance.

## Efficient Resource Loading

The Intersection Observer can delay the loading of certain resources, such as images, until they are actually needed:

```js
function callback(entries, observer) {
  entries.forEach((entry) => {
    if (entry.isIntersecting) {
      // Get the image
      let img = entry.target;
      // Set the URL to be a local file
      img.src = img.dataset.src;
      // Stop observing once image is loaded
      observer.unobserve(img);
    }
  });
}
```

However there is much more to this. Today we are going to explore stuff beyond lazy loading of images and see how async programming is implemented in the rest of JavaScript.

To understand anything async, we need to take a moment to appreciate the event loop.

# The Event loop

Both the browser and Node.js are always running a single threaded event loop to run your code.

![loop](./assets/loop.png)

On the first go around it will run all your synchronous code, but it also might queue up asynchronous events to be called back later. For example, let's say I have this function i need to run called `getStuff`, but first I need to get this data from the server.

![demo](./assets/1.png)

The event loop then goes "ok sounds good function, I'll keep doing my thing while you go do your thing"

![demo](./assets/2.png)

The function goes and does that in a separate thread pool

![demo](./assets/3.png)

Then at some point in the future `getStuff()` will finish and let the event loop know that it's ready to be "called back"

![demo](./assets/4.png)

It is at this point where things start to get a bit more complicated (I'm sorry). Depending on the type of task, the callback is triggered differently

- if its a big task, it will be executed on the next event loop
- if its a small task, it will be called back before the start of the next event loop

What does this mean? This will make (hopefully) more sense in the code.

# The Code behind the Loop

Lets run the following code in "Run and Debug" mode and add breakpoints to each of these lines of code:

```js
console.log("I am a synchronous task"); // 1

setTimeout(() => console.log("short timeout"), 0); // 2

Promise.resolve().then(() => console.log("what is a promise?")); // 3

console.log("I am also synchronous"); // 4
```

At first glance, you might think this will run each task in order, but that's not actually the case. Instead, the tasks will run in the order 1, 4, 3, 2, and the following will be printed to the console:

```text
I am a synchronous task
I am also synchronous
what is a promise?
short timeout
```

What is happening? For this you need to understand the difference in priority between synchronous tasks, micro tasks, and macro tasks

## Synchronous Tasks

Only when last task is done then go on to the next task.

## Asynchronous Macro Tasks

This does not block execution, however because it is a "Larger" task, the `callback` is only executed on the next iteration of the event loop.

Other examples of "Macro" Tasks include:

- `setTimeout`
- `setInterval`

## Asynchronous Micro Tasks

This does not block execution, however because it is a "Smaller" task, the `callback` is executed before the start of the next event loop.

Some "Micro" Tasks include:

- a returned `Promise` from the server

## Conclusion

Going back to our example, let's organize each of these statements into different categories of tasks:

```js
// Sync task
console.log("I am a synchronous task");
//  Macro task
setTimeout(() => console.log("short timeout"), 0);
// Micro task
Promise.resolve().then(() => console.log("what is a promise?"));
// Sync task
console.log("I am also synchronous");
```

So when we organize this by the order of tasks starting from sync, micro, followed by macro, the flow of execution is as follows:

```js
// Step 1 - Sync tasks are blocking
console.log("I am a synchronous task");
// Step TBD - Macro task does it's own thing on another thread
setTimeout(() => console.log("short timeout"), 0);
// Step TBD - Micro task does its own thing on another thread
Promise.resolve().then(() => console.log("what is a promise?"));
// Step 2 - Sync tasks are blocking and happen in order
console.log("I am also synchronous");
// Step 3 - the Micro task's callback finally gets executed
// Step 4 - the Marco task's callback finally gets executed
```

Which gives us the following output:

```text
I am a synchronous task
I am also synchronous
what is a promise?
short timeout
```

Now that we know how event loops work, we can start looking at promises.

## Visual Aid

If that's all still very confusing, this `gif` illustrates the concept quite well:

![tasks](./assets/tasks.gif)

# Promises && AJAX

## How is a promise based API consumed?

For the purposes of this class, we will be learning how to use AJAX to make requests to a server.

## What is AJAX?

AJAX (Asynchronous JavaScript and XML) allows web applications to send and retrieve data from a server asynchronously.

## How does it work?

![ajax](ajax.gif)

Why is this so neat? It allows parts of web pages to be asynchronously updated without reloading the whole page.

## How do you make a server request with AJAX?

The browser sends a request to the server via JavaScript, typically using the `XMLHttpRequest` object or using the more modern `fetch` API.

When you make a request to the server, you are being "promised" by that server that it will get the data you desire.

## How is that response consumed?

Once you get that response, it is consumed as a "Promise" with the contents of that message containing the data that was "requested".

## What happens to the Webpage?

Once JavaScript has finished processing the response, it updates specific parts of the webpage dynamically.

## Can you create Promises from scratch?

Yes, but you will likely make a lot of mistakes and we will slowly work our way up to such topics.

## Why even use AJAX?

- Server Side Form validation
- Lazy loading images from a server
- Search suggestions and autocomplete
- Notifications

## Docs

You can read more about it [here](https://www.w3schools.com/xml/ajax_intro.asp)

# XMLHttpRequest

All modern browsers have a built in XMLHttpRequest object

# fetch

# Async Operations Summary

Today we discussed the following async operations:

- Callbacks ðŸ‘‰ Functions passed as arguments that are executed once a task is completed.
- `Promise`s ðŸ‘‰ Objects representing a future result of an async operation, which can be resolved or rejected.

We will later cover `async` and `await` which is just a more readable syntax for working with Promises
