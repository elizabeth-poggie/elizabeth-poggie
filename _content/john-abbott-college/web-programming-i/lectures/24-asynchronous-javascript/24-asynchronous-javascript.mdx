---
# General Information
category: "Web Programming I"
title: "Asynchronous JavaScript"
created: "2024-10-20"
number: 24
---

# Quick Recap

Last week, we took time to familiarize ourselves with the syntax associated with the Intersection Observer API. Today we are going to get more into the theory

# Asynchronous Programming

Async programming allows code to execute without blocking the main thread, enabling other operations to continue while waiting for other tasks to complete.

## How does this relate to Web Development?

This is especially important in web development to avoid freezing or slowing down a page while waiting for resources from a server.

## In the context of Web Development, what is the main thread?

In the context of web development, the main thread refers to the single thread where most of the execution of JavaScript, rendering of HTML/CSS, event handling, and general browser operations occur.

## What blocks the main thread?

JavaScript is traditionally single-threaded, meaning it runs one task at a time on the main thread. However many things we do in the web tend to be time consuming or "blocking" causing the browser to freeze or become unresponsive.

## What are common blocking operations?

Synchronous tasks (like loops or long computations) can block the main thread, preventing it from doing other work. Some examples include:

- Long loops and complex calculations
- Modifying the DOM and heavy DOM traversal (e.g. animations)
- Any synchronous file operations (e.g. reading large files using local file access)
- Parsing Large JSON

## How does Async Programming help?

To prevent blocking the main thread, web developers use asynchronous programming to offload tasks that can take time, such as `fetch`ing data from a server or performing complex calculations.

## Why is this so useful?

The browser can continue to render and respond to user interactions while the task completes in the background.

# Async Programming and the IntersectionObserver API

## Why does async programming relate to the IntersectionObserver API?

The Intersection Observer API allows you to "asynchronously" observe changes in the intersection of a `target` element within a viewport. The main benefits include and are not limited to:

- Non blocking behavior
- Efficient Resource Loading

## Non-blocking Behavior

The Intersection Observer API performs asynchronous observation of elements. You specify what to `observe()`

```js
observer.observe(someElement);
```

When the conditions are met (like an element entering the viewport), a "callback" is triggered.

```js
const observer = new IntersectionObserver(callback);
```

This happens asynchronously, without blocking the main thread which improves performance.

## Efficient Resource Loading

The Intersection Observer can delay the loading of certain resources, such as images, until they are actually needed:

```js
function callback(entries, observer) {
  entries.forEach((entry) => {
    if (entry.isIntersecting) {
      // Get the image
      let img = entry.target;
      // Set the URL to be a local file
      img.src = img.dataset.src;
      // Stop observing once image is loaded
      observer.unobserve(img);
    }
  });
}
```

However there is much more to this. Today we are going to explore stuff beyond lazy loading of images and see how async programming is implemented in the rest of JavaScript.

To understand anything async, we need to take a moment to appreciate the event loop.

# The Event loop

Both the browser and Node.js are always running a single threaded event loop to run your code.

On the first go around it will run all your synchronous code, but it also might queue up asynchronous events to be called back later

For example, let's say I have this function i need to run called `getStuff`, but first I need to get this data from the server.

The event loop then goes "ok sounds good function, I'll keep doing my thing while you go do your thing"

The function goes and does that in a separate thread pool

Then at some point in the future `getStuff()` will finish and let the event loop know that it's ready to be "called back"

This is where things start to get a bit more complicated.

- if its a big task, it will be executed on the next event loop
- if its a small task, it will be called back before the start of the next event loop

What does this mean? This will make more sense in the code.

# The Code behind the Loop

Lets run the following code in "Run and Debug" mode and add breakpoints to each of these lines of code:

```js
console.log("I am a synchronous task"); // 1

setTimeout(() => console.log("short timeout"), 0); // 2

Promise.resolve().then(() => console.log("what is a promise?")); // 3

console.log("I am also synchronous"); // 4
```

On first glance you might think that this will run each of these tasks in order, however that is not the case. Instead the order will be 1,4,3,2 with the below printing to console:

```text
I am a synchronous task
I am also synchronous
what is a promise?
short timeout
```

What is happening? For this you need to understand the difference in priority between synchronous tasks, micro tasks, and macro tasks

## Synchronous Tasks

Only when last task is done then go on to the next task

## Asynchronous Macro Tasks

This does not block execution, however because it is a "Larger" task, the `callback` is only executed on the next iteration of the event loop.

Other examples of "Macro" Tasks include:

- `setTimeout`
- `setInterval`

## Asynchronous Micro Tasks

This does not block execution, however because it is a "Smaller" task, the `callback` is executed before the start of the next event loop.

## Conclusion

Going back to our example, let's organize each of these statements into different categories of tasks:

```js
// Sync task
console.log("I am a synchronous task");
//  Macro task
setTimeout(() => console.log("short timeout"), 0);
// Micro task
Promise.resolve().then(() => console.log("what is a promise?"));
// Sync task
console.log("I am also synchronous");
```

So when we organize this by the order of tasks starting from sync, micro, followed by macro, the flow of execution is as follows:

```js
// Step 1 - Sync tasks are blocking
console.log("I am a synchronous task");
// Step 4 - Macro task does it's own thing on another thread
setTimeout(() => console.log("short timeout"), 0);
// Step 3 - Micro task does its own thing on another thread
Promise.resolve().then(() => console.log("what is a promise?"));
// Step 2 - Sync tasks are blocking and happen in order
console.log("I am also synchronous");
```

Which gives us the following output:

```text
I am a synchronous task
I am also synchronous
what is a promise?
short timeout
```

# Promises

# Async / Await

# Handling Async Operations

Async operations in JavaScript are often handled using:

- Callbacks ðŸ‘‰ Functions passed as arguments that are executed once a task is completed.
- `Promise`s ðŸ‘‰ Objects representing a future result of an async operation, which can be resolved or rejected.
- `async`/`await` ðŸ‘‰ A more readable syntax for working with Promises, making async code look synchronous.

# Ajax

Asynchronous JavaScript and XML

Allows parts of web pages to be asynchronously updated without reloading the whole page.

It is not a programming language, it is a technique.

Uses the browser XMLHttpRequest object.
