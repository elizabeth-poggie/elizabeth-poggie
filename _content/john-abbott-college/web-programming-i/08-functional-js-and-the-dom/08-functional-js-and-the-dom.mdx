---
# General Information
category: "Web Programming I"
title: "Functional JS & The DOM"
created: "2024-09-08"
coverSrc: "./assets/"
---

# What is Functional Programming?

## Introduction

Last class I introduced the `forEach()` loop for working with arrays, assuming you were already familiar with the idea of passing functions as arguments. I built on the material from previous instructors, however, after reviewing your program outline, I found out that this concept is only introduced at the end of Programming 4.

This raises a couple of questions:

- Why is this class scheduled before you've learned this concept?
- How has this issue gone unnoticed until now?

I'll be discussing this with the department to address the curriculum gap. In the meantime, Iâ€™ll give you a quick crash course on passing functions as arguments, since itâ€™s a fundamental part of JavaScript and comes up frequently in its syntax.

## Who uses Functional Programming?

- Web developers (e.g. you guys in this class) for array manipulation cause we love clean code and efficiency.
- Data Scientists because it's ability to handle large datasets with less errors.
- Financial Institutions, specifically Banks, because its _stateless_ meaning it avoids maintaining or modifying state.

## Pros & Cons of Functional Programming

The Pros:

- It's clean
- Syntactic Efficiency.
- Reduction of Errors. You will make less mistakes in the long run.

The Cons:

- More abstract therefore a steeper learning curve. You are coding more "symbolically".

## What are the Key Concepts?

- Pure Functions: Functions that, given the same inputs, always produce the same outputs without causing any side effects (such as modifying variables outside the function).

- Immutability: In functional programming, data is not modified. Instead, new data is created when changes are needed, avoiding the concept of mutable state.

- No Side Effects: Since pure functions do not alter any state, they don't produce unexpected results that depend on external factors.

What exactly do all these concepts mean in code, let's get into it :)

# Pure Functions

When we talk about functional programming, the subject of a "pure" function comes up a lot. What is a pure function? It returns the same result provided the same parameters. For example:

```js
// This is a "pure" function
function add(a, b) {
  return a + b; // returns a + b
}
```

This is "pure" because when we call the function `add(2,5);` it will ALWAYS return `7`. The results are PREDICTABLE. What would make this function "impure"?

```js
// This is an "impure" function
function add(a, b) {
  return Math.random(); // returns ????
}
```

If we use the `Math` object to return a random number, then even if the parameters are called the same, then the return value is ALWAYS going to be DIFFERENT.

Why am I mentioning this? In JavaScript, not all functions can be pure.

## Purity vs Impurity

```js
// This is an "impure" function
const c = 9;
function add(a, b) {
  return c + a;
}
add(2, 5); // 10
```

The above is an "impure function" because `add` uses the external constant `c` and therefore the result of the function is influenced by something other than its arguements `a` and `b`, making it "impure". How could we modify this function to make it pure?

```js
// This is STILL an "impure" function
const c = 9;
function add(a, b) {
  return 9 + a;
}
add(2, 5); // 10
```

Even though the function no longer depends on the external variable `c`, it still uses the fixed value `9` internally. This makes the function less flexible and not purely dependent on its input parameters. The value of b is also unused, which may not be what you'd expect in a truly pure function. Ok so how do we fix it if we want to have a `const 9` that it relies on and also be "pure"?

```js
// This is a "pure" function
function add(a) {
  return 9 + a;
}
add(2); // 10
```

Why is this pure?

- The function DEPENDS on its input.
- It ALWAYS produces the same output for the same input.
- It is STATELESS and doesn't modify external state OR rely on external variables.

Why does this matter when it comes to programming functionally in JS? You don't want to change the state of your application. Why functions? Going back to what we know about scope, the state of your function does not impact the state of your application, or in other words, whatever happens in that function, stays in that function.

## Summary

To summarize, a pure function is a function that:

- Depends only on its input parameters and not on any external state or variables.
- ALWAYS returns the same output given the same inputs.
- Has no side effects, meaning it does not modify any external state or rely on it.

# Traditional Programming vs Functional Programming

Going back to our original way of traversing an array:

```js
const nums = [1, 2, 3];
let total = 0;

for (let i = 0; i < nums.length; i++) {
  total = total + nums[i];
}

console.log(total); // 6
```

In the above loop we are traversing an array and increasing each item by 1. To adapt the above to be a more functional programming style, we are going to put a lot of focus on the details. Now what do I mean by that?

Well in our loop, we are doing 2 things:

- Part 1) We are iterating over an array
- Part 2) We are performing an action over EACH item in in our array

```js
// ...

// Part 1) iterator using a for loop
for (let i = 0; i < nums.length; i++) {
  // Part 2) action
  total = total + nums[i];
}

// ...
```

What happens in a functional programming style is that we can disconnect the 2 an present the same thing BUT in a cleaner way.

We can rewrite the `for` loops to use a `forEach()` method that iterates over the loop.

```js
const nums = [1, 2, 3];
let total = 0;

// Part 1) iterator using forEach()
nums.forEach(function (num) {
  // Part 2) action
  total += num;
});

console.log(total); // 6
```

The above still respects our 2 important parts except now our action and iterator are INDEPENDENT from each other.

HOWEVER, this is not a pure function still. Why? It depends on and modifies external state (e.g. `total`). How do we fix this to become "PURE"? More on that in week 10 where we explore even MORE array methods including `map`, `filter`, and my favorite `reduce`.

Why is this so cool? We can put whatever function we want in here. Like lego blocks, you can build whatever structure you want. Your iterators can be interchanged with other iterators and your functions can be reused with other iterators.

## Example

Let's say we created the following "PURE" functions in one part of our code base.

```js
// Function to log elements
function logElement(element) {
  console.log(element);
}

// Function to check if the element is even
function checkEven(element) {
  if (typeof element !== "number" || !Number.isInteger(element)) {
    throw new Error("What are you doing giving me trash?");
  }
  const output = element % 2 === 0 ? element + " is even" : element + " is odd";
  console.log(output);
}
```

We can actually use these functions in multiple ways. For starters, on just individual elements of type `number`

```js
console.log(checkEven(42)); // 42 is even
console.log(checkEven(13)); // 13 is odd
console.log(checkEven("hello")); // trash
console.log(checkEven(19.99)); // trash
console.log(logElement(":^)")); // :^)
```

And we can also plug them directly into our array to be used:

```js
const nums = [1, 2, 3, 4, 5];
nums.forEach(checkEven);
nums.forEach(logElement);
```

Because the action AND iterator are decoupled from each other, if we ever need to make an adjustment to the `checkEven` function, the changes will impact all areas of the code base that use it.

## Exercise 1

# The DOM

As we dive deeper into building interactive User Interfaces, we'll explore how to integrate the JavaScript concepts we've learned with `HTML` and `CSS` to create dynamic webpages

## What is the DOM?

The Document Object Model (DOM) represents the structure of an HTML document as a tree of objects, which JavaScript can interact with. Although the DOM is not a part of the JavaScript language itself, it is an essential interface provided by the browser that allows JavaScript to engage and access the content and structure of a webpage.

## Key Points

The DOM is _NOT_:

- Part of the JavaScript Language

The DOM is:

- Constructed by the browser
- Accessible `globally` via the document object in JavaScript.

## The DOM and Trees

The Document Object Model (DOM) is organized as a tree structure with interconnected nodes, each representing a part of the HTML document:

![DOM](./assets/dom.png)

Each node in this tree is an object accessible through JavaScript. Just like other JavaScript objects, DOM nodes have key-value pairs. These pairs include both data and functions. For example, you can access specific elements in the DOM using methods like ...

```js
const element = document.getElementById("footer");
```

This line of code returns the HTML element with the ID `footer` if it exists. If no such element is found, it returns `null`.

# DOM Properties

The `HTMLElement` object is packed with _MANY_ properties. And when I say a lot, I mean _A LOT_. You can explore the complete list of properties [here](https://www.w3schools.com/jsref/dom_obj_all.asp)

However not all properties are created equal. Here are a few key _element properties_ that are particularly useful:

## innerHTML

`element.innerHTML` ðŸ‘‰ Modifying this property changes the content of the element. For example, setting `element.innerHTML` to a new value will update the text or HTML inside that element.

## id

`element.id` ðŸ‘‰ Sets or gets the `id` attribute of an element. This is useful for uniquely identifying an element within the DOM.

## style

`element.style` ðŸ‘‰ Provides access to the inline styles of an element. You can use it to change the appearance of the element directly through JavaScript.

## setAttribute

`element.setAttribute(name, value)` ðŸ‘‰ Sets a specified attribute on an element to a given value. This method is useful for setting any attribute that doesnâ€™t have a direct property.

## children

`element.children`ðŸ‘‰ Returns a live HTMLCollection of child elements of the specified element.

# DOM Methods

Here are a few key _document methods_ you will use a lot:

## getElementById

`document.getElementById(id)` ðŸ‘‰ This method returns an element with the specified id.

## getElementsByClassName

`document.getElementsByClassName(name)` ðŸ‘‰ This method returns a collection of elements with the specified class name, encapsulated in an HTMLCollection. Since a class name can be used by multiple elements, this method is designed to handle multiple matches.

## getElementsByTagName

`document.getElementsByTagName(name)` ðŸ‘‰ Similar to the class name method, this one returns a collection of elements with the specified tag name. This method also returns an HTMLCollection, as tag names can be shared by several elements.

# Exercise 2

So far we have been working mainly in CodePen, today is when we finally return to VSCode. Copy and paste the Pen on LEA into your VSCode and complete the exercise.

## Solution

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>FUNKY DOM Example</title>
    <style>
      .highlight {
        background-color: yellow;
      }
    </style>
  </head>
  <body>
    <h1 id="header">Welcome to the FUNKY DOM Example</h1>
    <p class="description">This is an example paragraph.</p>

    <script>
      const header = document.getElementById("header"); // Fixed
      console.log("Header:", header);

      // Change the content of the header
      header.innerHTML = "Content Updated!"; // Fixed
      console.log("Updated Header Content:", header.innerHTML);

      // Access the paragraph element by its class
      const paragraphs = document.getElementsByClassName("description"); // Fixed
      const paragraph = paragraphs[0]; // Get the first element from the HTMLCollection
      console.log("Paragraph:", paragraph);

      // Add a class to the paragraph
      paragraph.className = "highlight"; // Fixed
      console.log("Paragraph Class Name:", paragraph.className);
    </script>
  </body>
</html>
```
